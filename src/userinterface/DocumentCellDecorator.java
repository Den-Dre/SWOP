package userinterface;

import javax.swing.text.AbstractDocument;
import java.awt.*;
import java.util.ArrayList;
import java.util.Collections;

public abstract class DocumentCellDecorator extends DocumentCell {
    /**
     * Initialise this decorator with the given parameters.
     *
     * @param cell: The {@link DocumentCell} to be decorated
     * @throws IllegalDimensionException: When one of the dimensions of this AbstractFrame is negative
     */
    public DocumentCellDecorator(DocumentCell cell) throws IllegalDimensionException {
        super(cell.getxPos(), cell.getyPos(), cell.getWidth(), cell.getHeight());
        if (cell instanceof DocumentCellDecorator)
            this.cellToBeDecorated = cell;
        else
            this.cellToBeDecorated = wrapInDocumentCell(cell);

    }

    /**
     * Initialise this decorator with the given parameters.
     *
     * @param frame: The {@link ContentFrame} to be decorated
     * @throws IllegalDimensionException: When one of the dimensions of this AbstractFrame is negative
     */
    public DocumentCellDecorator(ContentFrame frame) throws IllegalDimensionException {
        super(frame.getContent().getxPos(), frame.getContent().getyPos(), frame.getContent().getWidth(), frame.getContent().getHeight());
        this.cellToBeDecorated = frame.getContent();
    }

    /**
     * render the graphics {@code g} of this DocumentCell.
     *
     * @param g : The graphics to be rendered.
     */
    @Override
    public void render(Graphics g) {
        // The two lines below are no longer needed as
        // the issue is addressed in the setters below
//        cellToBeDecorated.setxPos(this.getxPos());
//        cellToBeDecorated.setyPos(this.getyPos());
        cellToBeDecorated.render(g);
    }

    /**
     * Handle mouseEvents. Determine if this AbstractFrame was pressed and do the right actions.
     *
     * @param id          : The type of mouse activity
     * @param x           : The x coordinate of the mouse activity
     * @param y           : The y coordinate of the mouse activity
     * @param clickCount  : The number of clicks
     * @param button      : The mouse button that was clicked
     * @param modifiersEx : The control keys that were held on the click
     */
    @Override
    public void handleMouse(int id, int x, int y, int clickCount, int button, int modifiersEx) {
        this.cellToBeDecorated.handleMouse(id, x, y, clickCount, button, modifiersEx);
    }

    /**
     * The output generated by a mouse click on this DocumentCell.
     * This is always a {@link ReturnMessage} that contains the empty string "".
     *
     * @param id         : The id of the click
     * @param x          : The x coordinate of the click
     * @param y          : The y coordinate of the click
     * @param clickCount : The number of clicks that occured.
     * @param button     : Which mouse button was clicked.
     * @param modifier   : Extra control key that was held during the click.
     * @return ReturnMessage(ReturnMessage.Type.Empty): a {@link ReturnMessage} which contains the empty string {@code ""}.
     */
    @Override
    public ReturnMessage getHandleMouse(int id, int x, int y, int clickCount, int button, int modifier) {
        return this.cellToBeDecorated.getHandleMouse(id, x, y, clickCount, button, modifier);
    }

    /**
     * Handle key presses. This method does the right action when a key is pressed.
     *
     * @param id          : The KeyEvent (Associated with type of KeyEvent)
     * @param keyCode     : The KeyEvent code (Determines the involved key)
     * @param keyChar     : The character representation of the involved key
     * @param modifiersEx : Specifies other keys that were involved in the event
     */
    @Override
    public void handleKey(int id, int keyCode, char keyChar, int modifiersEx) {
        this.cellToBeDecorated.handleKey(id, keyCode, keyChar, modifiersEx);
    }

    /**
     * This method handles resizes.
     * It makes sure the AbstractFrame is adjusted in width when the window shrinks or grows.
     * It does not change its height (e.g. look at Firefox).
     *
     * <p>N.B.: without this method, {@code BookmarksBar} would be rendered with
     * the given absolute width, and thus one would need to guess the
     * correct initial size of the window. Using this method, widths are
     * automatically adjusted: both at initialization and at runtime.</p>
     *
     * @param newWindowWidth  : parameter containing the new window-width of this AbstractFrame.
     * @param newWindowHeight : parameter containing the new window-height of this AbstractFrame.
     */
    @Override
    public void handleResize(int newWindowWidth, int newWindowHeight) {
        this.cellToBeDecorated.handleResize(newWindowWidth, newWindowHeight);
        getContentWithoutScrollbars().handleResize(newWindowWidth, newWindowHeight);
    }

    // These setters are overridden to fix the issue
    // where `this` would contain the correct coordinates
    // after adding a `DocumentCellDecorator` to a UITable,
    // but the coordinates of `cellToBeDecorated` weren't updated yet.
    /**
     * Set the x position of this AbstractFrame to the given value
     *
     * @param xPos :
     *             The value this AbstractFrame's x position should be set to.
     */
    @Override
    public void setxPos(int xPos) {
        super.setxPos(xPos);
        this.cellToBeDecorated.setxPos(xPos);
    }

    /**
     * Set the y position of this AbstractFrame to the given value
     *
     * @param yPos :
     *             The value this AbstractFrame's y position should be set to.
     */
    @Override
    public void setyPos(int yPos) {
        super.setyPos(yPos);
        this.cellToBeDecorated.setyPos(yPos);
    }

    /**
     * Get the contents that are being decorated.
     *
     * @return cell: The {@link DocumentCell} object that is being decorated.
     */
    public DocumentCell getContent() {
        return this.cellToBeDecorated;
    }

    /**
     * Get the contents that are being decorated,
     * with all added scrollbar decorations omitted.
     *
     * @return cellToBeDecorated:
     *          the contents that are being decorated without any decorations
     */
    public DocumentCell getContentWithoutScrollbars() {
        if (this.cellToBeDecorated instanceof VerticalScrollBarDecorator)
            return ((VerticalScrollBarDecorator) this.cellToBeDecorated).getContentWithoutScrollbars();
        else if (this.cellToBeDecorated instanceof HorizontalScrollBarDecorator)
            return ((HorizontalScrollBarDecorator) this.cellToBeDecorated).getContentWithoutScrollbars();
        // In this case we have peeled off both the potentially added scroll bars
        // and are left with the wrapper `UITable` from which we extract the encapsulated element:
        return ((UITable) cellToBeDecorated).getContent().get(0).get(0);
    }

    /**
     * Wrap the given {@link DocumentCell} in a
     * {@link UITable} s.t. it can be easily decorated
     * by means of the decorator pattern which is implemented by
     * {@link VerticalScrollBarDecorator} and {@link HorizontalScrollBarDecorator}.
     *
     *
     * @param cell: The {@link DocumentCell} to be wrapped.
     * @return wrapped: The given {@link DocumentCell} wrapped in a {@link UITable}.
     */
    protected DocumentCell wrapInDocumentCell(DocumentCell cell) {
        ArrayList<ArrayList<DocumentCell>> overlayContents =
                new ArrayList<>(Collections.singletonList(new ArrayList<>(Collections.singletonList(cell))));
        return new UITable(cell.getxPos(), cell.getyPos(), cell.getMaxWidth(), cell.getMaxHeight(), overlayContents);
    }

    /**
     * Retrieve the names and values of the content of this decorator.
     * <p>
     * Only applies if the DocumentCell has a name and value (e.g UITextInputField)
     * or can contain elements that do (e.g. UITable).
     * </p>
     *
     * @return An ArrayList with the name and value of the DocumentCell separated by a '=' sign.
     */
    @Override
    public ArrayList<String> getNamesAndValues() {
        return getContentWithoutScrollbars().getNamesAndValues();
    }

    /**
     * A variable to denote the {@link DocumentCell} that will be decorated.
     */
    protected final DocumentCell cellToBeDecorated;

    /**
     * The height of the added horizontal scrolling bar.
     */
    protected final int SCROLLBAR_HEIGHT = 5;

    /**
     * The width of the added vertical scrolling bar.
     */
    protected final int SCROLLBAR_WIDTH = 5;
}
